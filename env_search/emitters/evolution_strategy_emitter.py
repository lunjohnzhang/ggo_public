import gin
import ribs
import numpy as np
from ribs._utils import validate_batch_args

@gin.configurable
class EvolutionStrategyEmitter(ribs.emitters.EvolutionStrategyEmitter):
    """gin-configurable version of pyribs EvolutionStrategyEmitter.
    Also implements some Darwinian bound handling approaches, described in this
    paper: https://www.sciencedirect.com/science/article/pii/S2210650219301622

    """

    def __init__(
        self,
        archive,
        *,
        x0,
        sigma0,
        ranker="2imp",
        es="cma_es",
        es_kwargs=None,
        selection_rule="filter",
        restart_rule="no_improvement",
        bounds=None,
        batch_size=None,
        seed=None,
    ):
        super().__init__(
            archive=archive,
            x0=x0,
            sigma0=sigma0,
            ranker=ranker,
            es=es,
            es_kwargs=es_kwargs,
            selection_rule=selection_rule,
            restart_rule=restart_rule,
            bounds=bounds,
            batch_size=batch_size,
            seed=seed,
        )
        self._n_restart_from_area = 0

    def ask(self):
        sols = super().ask()

        # # Handle bounds. All handling here are `Darwinian` approach, where
        # # `repaired` solutions are not passed to `tell` method
        # if self._bound_handle is not None:
        #     # Project values out of bounds to the bounds.
        #     if self._bound_handle == "projection":
        #         sols = np.clip(sols, self._lower_bounds, self._upper_bounds)
        #     # Reflect values out of bounds around the bounds.
        #     elif self._bound_handle == "reflection":
        #         l_oob = sols < self._lb_tile
        #         sols[l_oob] = 2 * self._lb_tile[l_oob] - sols[l_oob]
        #         r_oob = sols > self._ub_tile
        #         sols[r_oob] = 2 * self._ub_tile[r_oob] - sols[r_oob]

        # Return addition None to cope with parent sol API of
        # MapElitesBaselineWarehouseEmitter
        # assert
        return sols, None

    def tell(self,
             solution_batch,
             objective_batch,
             measures_batch,
             status_batch,
             value_batch,
             metadata_batch=None):
        """Gives the emitter results from evaluating solutions.

        The solutions are ranked based on the `rank()` function defined by
        `self._ranker`. Then, the ranked solutions are passed to CMA-ES for
        adaptation.

        This function also checks for restart condition and restarts CMA-ES
        when needed.

        Args:
            solution_batch (array-like): (batch_size, :attr:`solution_dim`)
                array of solutions generated by this emitter's :meth:`ask()`
                method.
            objective_batch (array-like): 1D array containing the objective
                function value of each solution.
            measures_batch (array-like): (batch_size, measure space
                dimension) array with the measure space coordinates of each
                solution.
            status_batch (array-like): 1D array of
                :class:`ribs.archive.AddStatus` returned by a series of calls
                to archive's :meth:`add()` method.
            value_batch (array-like): 1D array of floats returned by a series
                of calls to archive's :meth:`add()` method. For what these
                floats represent, refer to :meth:`ribs.archives.add()`.
            metadata_batch (array-like): 1D object array containing a metadata
                object for each solution.
        """
        # Preprocessing arguments.
        solution_batch = np.asarray(solution_batch)
        objective_batch = np.asarray(objective_batch)
        measures_batch = np.asarray(measures_batch)
        status_batch = np.asarray(status_batch)
        value_batch = np.asarray(value_batch)
        batch_size = solution_batch.shape[0]
        metadata_batch = (np.empty(batch_size, dtype=object) if
                          metadata_batch is None else np.asarray(metadata_batch,
                                                                 dtype=object))

        # Validate arguments.
        validate_batch_args(archive=self.archive,
                            solution_batch=solution_batch,
                            objective_batch=objective_batch,
                            measures_batch=measures_batch,
                            status_batch=status_batch,
                            value_batch=value_batch,
                            metadata_batch=metadata_batch)

        # Increase iteration counter.
        self._itrs += 1

        # Count number of new solutions.
        new_sols = status_batch.astype(bool).sum()

        # Sort the solutions using ranker.
        indices, ranking_values = self._ranker.rank(
            self, self.archive, self._rng, solution_batch, objective_batch,
            measures_batch, status_batch, value_batch, metadata_batch)

        # Select the number of parents.
        num_parents = (new_sols if self._selection_rule == "filter" else
                       self._batch_size // 2)

        # Update Evolution Strategy.
        self._opt.tell(indices, num_parents)

        # Check for reset.
        if (self._opt.check_stop(ranking_values[indices]) or
                self._check_restart(new_sols)):
            new_x0 = self.archive.sample_elites(1).solution_batch[0]
            self._opt.reset(new_x0)
            self._ranker.reset(self, self.archive, self._rng)
            self._restarts += 1
            self._n_restart_from_area = self._opt._n_restart_from_area

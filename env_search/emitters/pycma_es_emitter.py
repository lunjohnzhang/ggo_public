import gin
import ribs
import numpy as np
import cma
from ribs._utils import check_1d_shape, validate_batch_args


@gin.configurable
class PyCMAEmitter(ribs.emitters.EmitterBase):
    """CMA-ES emitter implemented using pycma library

    Args:
        archive (ribs.archives.ArchiveBase): An archive to use when creating
            and inserting solutions. For instance, this can be
            :class:`ribs.archives.GridArchive`.
        x0 (np.ndarray): Initial solution. Must be 1-dimensional.
        sigma0 (float): Initial step size / standard deviation.
        es_kwargs (dict): Additional arguments to pass to the evolution
            strategy optimizer `cma.CMAEvolutionStrategy` of pycma.
        bounds (None or array-like): Bounds of the solution space. As suggested
            in `Biedrzycki 2020
            <https://www.sciencedirect.com/science/article/abs/pii/S2210650219301622>`_,
            solutions are resampled until they fall within these bounds.  Pass
            None to indicate there are no bounds. Alternatively, pass an
            array-like to specify the bounds for each dim. Each element in this
            array-like can be None to indicate no bound, or a tuple of
            ``(lower_bound, upper_bound)``, where ``lower_bound`` or
            ``upper_bound`` may be None to indicate no bound.
        batch_size (int): Number of solutions to return in :meth:`ask`. If not
            passed in, a batch size will be automatically calculated using the
            default CMA-ES rules.
        seed (int): Value to seed the random number generator. Set to None to
            avoid a fixed seed.
    """

    def __init__(
        self,
        archive,
        *,
        x0,
        sigma0,
        es_kwargs=None,
        bounds=None,
        seed=None,
        batch_size=None,
    ):
        super().__init__(
            archive,
            solution_dim=archive.solution_dim,
            bounds=bounds,
        )
        self._x0 = np.array(x0, dtype=archive.dtype)
        check_1d_shape(self._x0, "x0", archive.solution_dim,
                       "archive.solution_dim")
        self._sigma0 = sigma0
        self._batch_size = batch_size
        inopts = {
            "seed": seed,
            # "bounds":
            # [self._lower_bounds.tolist(),
            #  self._upper_bounds.tolist()],
            "popsize": batch_size,
            "verb_log": 0,
            "verb_disp": 0,
        }
        if es_kwargs is not None:
            inopts.update(es_kwargs)
        self._opt = cma.CMAEvolutionStrategy(
            x0,
            sigma0,
            inopts=inopts,
        )

        self._itrs = 0

    @property
    def x0(self):
        """numpy.ndarray: Initial solution for the optimizer."""
        return self._x0

    @property
    def batch_size(self):
        """int: Number of solutions to return in :meth:`ask`."""
        return self._batch_size

    @property
    def restarts(self):
        """int: The number of restarts for this emitter."""
        return self._restarts

    @property
    def itrs(self):
        """int: The number of iterations for this emitter, where each iteration
        is a call to :meth:`tell`."""
        return self._itrs

    def ask(self):
        """Samples new solutions from a multivariate Gaussian.
        The multivariate Gaussian is parameterized by the evolution strategy
        optimizer ``self._opt`` (aka ``cma.CMAEvolutionStrategy`` in this
        emitter)

        Returns:
            (batch_size, :attr:`solution_dim`) array -- a batch of new solutions
            to evaluate.
        """
        sols = self._opt.ask()
        return np.asarray(sols), None

    def tell(
        self,
        solution_batch,
        objective_batch,
        measures_batch,
        status_batch,
        value_batch,
        metadata_batch=None,
    ):
        """Gives the emitter results from evaluating solutions.

        Note that only `solution_batch` and `objective_batch` are used because
        this emitter runs pure CMA-ES. Other parameters are added to conform to
        the API of pyribs.

        Args:
            solution_batch (array-like): (batch_size, :attr:`solution_dim`)
                array of solutions generated by this emitter's :meth:`ask()`
                method.
            objective_batch (array-like): 1D array containing the objective
                function value of each solution.
            measures_batch (array-like): (batch_size, measure space
                dimension) array with the measure space coordinates of each
                solution.
            status_batch (array-like): 1D array of
                :class:`ribs.archive.AddStatus` returned by a series of calls
                to archive's :meth:`add()` method.
            value_batch (array-like): 1D array of floats returned by a series
                of calls to archive's :meth:`add()` method. For what these
                floats represent, refer to :meth:`ribs.archives.add()`.
            metadata_batch (array-like): 1D object array containing a metadata
                object for each solution.
        """
        solution_batch = np.asarray(solution_batch)
        objective_batch = np.asarray(objective_batch)
        measures_batch = np.asarray(measures_batch)
        status_batch = np.asarray(status_batch)
        value_batch = np.asarray(value_batch)
        batch_size = solution_batch.shape[0]
        metadata_batch = (np.empty(batch_size, dtype=object)
                          if metadata_batch is None else np.asarray(
                              metadata_batch, dtype=object))
        # Validate arguments.
        validate_batch_args(archive=self.archive,
                            solution_batch=solution_batch,
                            objective_batch=objective_batch,
                            measures_batch=measures_batch,
                            status_batch=status_batch,
                            value_batch=value_batch,
                            metadata_batch=metadata_batch)

        # Increase iteration counter.
        self._itrs += 1

        # Update pycma optimizer. Note that pycma naturally minimize, therefores
        # we add negative sign.
        # print(self._opt.result_pretty())
        self._opt.tell(solution_batch, -objective_batch)
